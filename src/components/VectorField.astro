---
interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<div class={`flow-field-container ${className}`}>
  <canvas id="flow-field"></canvas>
</div>

<script>
  const canvas = document.getElementById('flow-field') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  interface Spline {
    points: { x: number; y: number }[];
    offset: number;
    speed: number;
    width: number;
    opacity: number;
  }

  let splines: Spline[] = [];
  let width = 0;
  let height = 0;
  let time = 0;
  let animationId: number;

  function resize() {
    const container = canvas.parentElement!;
    const rect = container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    width = rect.width;
    height = rect.height;

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    ctx.scale(dpr, dpr);

    generateSplines();
  }

  function generateSplines() {
    splines = [];

    // Calculate spline count based on area (fewer on mobile)
    const area = width * height;
    const baseCount = Math.max(6, Math.min(18, Math.floor(area / 40000)));

    for (let i = 0; i < baseCount; i++) {
      const points: { x: number; y: number }[] = [];
      const numPoints = 5 + Math.floor(Math.random() * 3);

      // Start from left side, flow to right
      const startY = Math.random() * height;
      const yDrift = (Math.random() - 0.5) * height * 0.4;

      for (let j = 0; j < numPoints; j++) {
        const t = j / (numPoints - 1);
        points.push({
          x: t * width * 1.2 - width * 0.1,
          y: startY + yDrift * t + (Math.random() - 0.5) * 80,
        });
      }

      splines.push({
        points,
        offset: Math.random() * 1000,
        speed: 0.3 + Math.random() * 0.4,
        width: 1 + Math.random() * 1.5,
        opacity: 0.08 + Math.random() * 0.12,
      });
    }
  }

  function catmullRom(p0: number, p1: number, p2: number, p3: number, t: number): number {
    const t2 = t * t;
    const t3 = t2 * t;
    return 0.5 * (
      (2 * p1) +
      (-p0 + p2) * t +
      (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
      (-p0 + 3 * p1 - 3 * p2 + p3) * t3
    );
  }

  function getSplinePoint(spline: Spline, t: number, timeOffset: number): { x: number; y: number } {
    const points = spline.points;
    const n = points.length - 1;
    const segment = Math.min(Math.floor(t * n), n - 1);
    const localT = (t * n) - segment;

    const p0 = points[Math.max(0, segment - 1)];
    const p1 = points[segment];
    const p2 = points[Math.min(n, segment + 1)];
    const p3 = points[Math.min(n, segment + 2)];

    // Add gentle wave motion
    const wave = Math.sin(t * Math.PI * 2 + timeOffset) * 15;

    return {
      x: catmullRom(p0.x, p1.x, p2.x, p3.x, localT),
      y: catmullRom(p0.y, p1.y, p2.y, p3.y, localT) + wave,
    };
  }

  function drawSpline(spline: Spline, timeOffset: number) {
    ctx.beginPath();
    ctx.strokeStyle = `rgba(107, 114, 128, ${spline.opacity})`;
    ctx.lineWidth = spline.width;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const steps = 80;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const point = getSplinePoint(spline, t, timeOffset);

      if (i === 0) {
        ctx.moveTo(point.x, point.y);
      } else {
        ctx.lineTo(point.x, point.y);
      }
    }

    ctx.stroke();
  }

  function drawStatic() {
    ctx.clearRect(0, 0, width, height);
    splines.forEach((spline) => {
      drawSpline(spline, 0);
    });
  }

  function animate() {
    ctx.clearRect(0, 0, width, height);

    splines.forEach((spline) => {
      const timeOffset = (time * spline.speed * 0.01) + spline.offset;
      drawSpline(spline, timeOffset);
    });

    time++;
    animationId = requestAnimationFrame(animate);
  }

  // Initialize
  resize();

  if (prefersReducedMotion) {
    drawStatic();
  } else {
    animate();
  }

  // Handle resize
  let resizeTimeout: number;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      resize();
      if (prefersReducedMotion) {
        drawStatic();
      }
    }, 150);
  });

  // Cleanup
  document.addEventListener('astro:before-preparation', () => {
    cancelAnimationFrame(animationId);
  });
</script>

<style>
  .flow-field-container {
    position: fixed;
    top: 0;
    right: 0;
    width: 50vw;
    height: 100vh;
    pointer-events: none;
    z-index: -1;
  }

  #flow-field {
    width: 100%;
    height: 100%;
  }

  @media (max-width: 768px) {
    .flow-field-container {
      width: 100vw;
      opacity: 0.5;
    }
  }
</style>
