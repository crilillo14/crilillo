---
interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<div class={`vector-field-container ${className}`}>
  <canvas id="vector-field"></canvas>
</div>

<script>
  const canvas = document.getElementById('vector-field') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // Configuration
  const config = {
    baseParticlesPerPixel: 0.00004, // particles per pixel of canvas area
    minParticles: 20,
    maxParticles: 200,
    particleSpeed: 0.8,
    noiseScale: 0.003,
    lineLength: 20,
    lineWidth: 1,
    fadeSpeed: 0.03,
    color: { r: 107, g: 114, b: 128 }, // muted gray
  };

  // Simplex-like noise (simplified Perlin)
  function noise(x: number, y: number, z: number): number {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    const u = fade(x);
    const v = fade(y);
    const w = fade(z);

    const A = p[X] + Y;
    const AA = p[A] + Z;
    const AB = p[A + 1] + Z;
    const B = p[X + 1] + Y;
    const BA = p[B] + Z;
    const BB = p[B + 1] + Z;

    return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
                                   grad(p[BA], x - 1, y, z)),
                           lerp(u, grad(p[AB], x, y - 1, z),
                                   grad(p[BB], x - 1, y - 1, z))),
                   lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1),
                                   grad(p[BA + 1], x - 1, y, z - 1)),
                           lerp(u, grad(p[AB + 1], x, y - 1, z - 1),
                                   grad(p[BB + 1], x - 1, y - 1, z - 1))));
  }

  function fade(t: number): number {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  function lerp(t: number, a: number, b: number): number {
    return a + t * (b - a);
  }

  function grad(hash: number, x: number, y: number, z: number): number {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  // Permutation table
  const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
  const p = new Array(512);
  for (let i = 0; i < 256; i++) p[256 + i] = p[i] = permutation[i];

  interface Particle {
    x: number;
    y: number;
    age: number;
    maxAge: number;
  }

  let particles: Particle[] = [];
  let time = 0;
  let animationId: number;

  function resize() {
    const container = canvas.parentElement!;
    const rect = container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;

    ctx.scale(dpr, dpr);

    // Calculate particle count based on area
    const area = rect.width * rect.height;
    const particleCount = Math.min(
      config.maxParticles,
      Math.max(config.minParticles, Math.floor(area * config.baseParticlesPerPixel))
    );

    // Reset particles
    particles = [];
    for (let i = 0; i < particleCount; i++) {
      particles.push(createParticle(rect.width, rect.height));
    }
  }

  function createParticle(width: number, height: number): Particle {
    return {
      x: Math.random() * width,
      y: Math.random() * height,
      age: Math.random() * 100,
      maxAge: 80 + Math.random() * 40,
    };
  }

  function getAngle(x: number, y: number, t: number): number {
    return noise(x * config.noiseScale, y * config.noiseScale, t * 0.0005) * Math.PI * 4;
  }

  function drawStatic() {
    const rect = canvas.parentElement!.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);

    const { r, g, b } = config.color;
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
    ctx.lineWidth = config.lineWidth;

    const gridSize = 30;
    const cols = Math.ceil(rect.width / gridSize);
    const rows = Math.ceil(rect.height / gridSize);

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        const x = i * gridSize + gridSize / 2;
        const y = j * gridSize + gridSize / 2;
        const angle = getAngle(x, y, 0);

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(
          x + Math.cos(angle) * config.lineLength,
          y + Math.sin(angle) * config.lineLength
        );
        ctx.stroke();
      }
    }
  }

  function animate() {
    const rect = canvas.parentElement!.getBoundingClientRect();

    // Fade effect
    ctx.fillStyle = 'rgba(250, 250, 250, 0.05)';
    ctx.fillRect(0, 0, rect.width, rect.height);

    const { r, g, b } = config.color;

    particles.forEach((particle) => {
      const angle = getAngle(particle.x, particle.y, time);

      // Calculate opacity based on age
      const lifeRatio = particle.age / particle.maxAge;
      const opacity = lifeRatio < 0.1
        ? lifeRatio * 10
        : lifeRatio > 0.9
          ? (1 - lifeRatio) * 10
          : 1;

      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity * 0.4})`;
      ctx.lineWidth = config.lineWidth;

      ctx.beginPath();
      ctx.moveTo(particle.x, particle.y);

      // Move particle
      particle.x += Math.cos(angle) * config.particleSpeed;
      particle.y += Math.sin(angle) * config.particleSpeed;

      ctx.lineTo(particle.x, particle.y);
      ctx.stroke();

      particle.age++;

      // Reset particle if it's too old or out of bounds
      if (
        particle.age > particle.maxAge ||
        particle.x < 0 ||
        particle.x > rect.width ||
        particle.y < 0 ||
        particle.y > rect.height
      ) {
        Object.assign(particle, createParticle(rect.width, rect.height));
      }
    });

    time++;
    animationId = requestAnimationFrame(animate);
  }

  // Initialize
  resize();

  if (prefersReducedMotion) {
    drawStatic();
  } else {
    animate();
  }

  // Handle resize
  let resizeTimeout: number;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      resize();
      if (prefersReducedMotion) {
        drawStatic();
      }
    }, 100);
  });

  // Cleanup on page navigation (for Astro)
  document.addEventListener('astro:before-preparation', () => {
    cancelAnimationFrame(animationId);
  });
</script>

<style>
  .vector-field-container {
    position: fixed;
    top: 0;
    right: 0;
    width: 40vw;
    height: 100vh;
    pointer-events: none;
    z-index: -1;
    opacity: 0.6;
  }

  #vector-field {
    width: 100%;
    height: 100%;
  }

  @media (max-width: 768px) {
    .vector-field-container {
      width: 100vw;
      opacity: 0.3;
    }
  }
</style>
